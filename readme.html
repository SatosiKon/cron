<h1>Seam Cron</h1>

<h2>Huh??</h2>

<p>Glad you asked. Seam Cron is a CDI portable extension which allows you to 
elegantly execute scheduled and asynchronous methods from your CDI project.
Here's a glimpse of what's possible:</p>

<pre><code>public void howlAtTheMoon(@Observes @AtMidnight CronEvent event) {
    wolf.howl();
}
</code></pre>

<p><code>@AtMidnight</code> is a CDI-style custom qualifier which might look a little like this:</p>

<pre><code>@Scheduled("00:00")
@Qualifier
@Retention( RUNTIME )
@Target( { PARAMETER })
public @interface AtMidnight
{
}
</code></pre>

<p>Instead of <code>"00:00"</code> you could use full cron-style syntax (eg: <code>@Scheduled("0 0 0 ? * *")</code>)
or you could use an arbitrary name (eg: <code>@Scheduled("at.midnight")</code>), which would then 
be resolved into a time using the <code>scheduler.properties</code> file at the root of your classpath:</p>

<pre><code># scheduler.properties
at.midnight=00:00
</code></pre>

<p>Alternatively you could just put the schedule definition directly into the <code>@Scheduled</code> 
annotation on the method to be scheduled, but that would be a rather masochistic thing to do.</p>

<p>If your requirements are fairly simple, for example running a task repeatedly at 
a specific interval, then you can use the <code>@Every</code> qualifier like so:</p>

<pre><code>public void ringTheBell(@Observes @Every(HOUR)
</code></pre>

<h2>MEH. What else you got?</h2>

<p>You're kidding right?</p>

<p>OK well, there's also this:</p>

<pre><code>@Inject @HumanSeeking Missile missile;

public String destroyAllHumans() {
    initiateRatherDrawnOutMissileLaunchSequence();
    return "Those humans be good as dead";
}

@Asynchronous
public MissileDeployment initiateRatherDrawnOutMissileLaunchSequence() {
    return missile.launchViaSOAPWebServicesDeployedOnAPentiumIIRunningWindowsNTAndNortonAntiVirus();
}
</code></pre>

<p>OK, so that asynchronous method returns an instance of <code>MissileDeployment</code>. 
So how do you get your hands on it? Easy!</p>

<pre><code>public void verifyDeployment(@Observes MissileDeployment deployment) {
    if ("EPIC FAIL".equals(deployment.getStatus())) {
        henchmen.head().fire();
    } else {
        champagne.pop();
    }
}
</code></pre>

<p>The rules concerning return types of @Asynchronous methods are as follows:</p>

<ul>
<li>If method return type is void, no event will be fired</li>
<li>If the method invocation returns a value of null, no event will be fired. Be careful of this!</li>
</ul><p>You would typically want one dedicated return type per asynchronous method invocation
for a one-to-one mapping between methods and their observers, but there may be use
cases for having multiple asynchronous methods all reporting their results to a single
observer, and Cron would be totally cool with that. Alternatively you might wish
to introduce some additional CDI-style qualifiers like so:</p>

<pre><code>@Asynchronous @Credit
public Balance addCredit(int dollars) {
    ...
    return new Ballance();
}

@Asynchronous @Debit
public Balance addDebit(int dollars) {
    ...
    return new Ballance();
}

public void reportNewBalance(@Observes Balance balance) {
    log.report(balance.amount());
}

public void trackSpending(@Observes @Debit Balance balance) {
    db.saveSomething();
}
</code></pre>

<p>Finally, if you prefer a more traditional, EJB-esque approach then you can specify
a return type of Future and use the <code>AsyncResult</code> helper to return the result
of your method call. Seam Cron will automatically wrap this in a legit Future
which the calling code can use as expected immediately.</p>

<pre><code>@Asynchronous
public Future&lt;Blah&gt; doSomeHeavyLiftingInTheBackground() {
    ...
    return new AsyncResult(new Blah());
}
</code></pre>

<p>And the calling code:</p>

<pre><code>@Inject LiftingBean liftingBean;

public void someMethod() {
    Future&lt;Blah&gt; future = liftingBean.doSomeHeavyLiftingInTheBackground();
    // blocks until asynch method returns or gives up
    Blah result = future.get(10, SECONDS);
}

</code></pre>

<h2>ENOUGH!! How do get I it?</h2>

<p>Well it's alpha software so it's not available in any Maven repository just yet.
I know I know, it's a crime. But you can install it into your local maven repository in just
3 easy steps:</p>

<pre><code>git clone git://github.com/seam/cron.git
cd cron
mvn clean install -Popenwebbeans-embedded-1
</code></pre>

<h2>OPEN WEB BEANS!?!!?</h2>

<p>Yes well. There's a bit of a bug in Weld at the moment (WELD-862) which stops 
<code>@Asynchronous</code> from working properly. You're welcome to go ahead and use Seam Cron
in your project and all the scheduling stuff will work just tickety boo. But if
you're hoping to use @Asynchronous and you're deploying to JBoss AS or Glassfish
you're gonna be out of luck. In that case you'd better head straight over to 

<a href="https://issues.jboss.org/browse/WELD-862">https://issues.jboss.org/browse/WELD-862</a> and moan loudly until it gets sorted out.</p>

<h2>This is awesome but not awesome enough yet.</h2>

<p>I know, it's true. But you can help. If you know exactly what you need and have 
the skillpower to get it done, then please fork this project and submit a pull 
request. Alternatively submit a feature request or bug report over at JIRA:
<a href="https://issues.jboss.org/browse/SEAMCRON">https://issues.jboss.org/browse/SEAMCRON</a>
